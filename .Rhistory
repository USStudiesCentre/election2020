mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(
gam = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graph = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
# formula = y ~ s(x, k = 3)
) +
scale_x_reverse() +
theme_ussc()
))
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 6 polls
filter(map_int(rolling_t, nrow) >= 6) %>%
# find distinct e_ct and p_ct
mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_mdoels = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 4 polls in each window
filter(map_int(rolling_t, nrow) >= 4) %>%
# find distinct e_ct and p_ct
mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_mdoels = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 4 polls in each window
filter(map_int(rolling_t, nrow) >= 5) %>%
# find distinct e_ct and p_ct
mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_mdoels = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 4 polls in each window
filter(map_int(rolling_t, nrow) >= 5) %>%
# find distinct e_ct and p_ct
mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_mdoels = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 4) +
s(e_ct, k = 4),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
extract_iowa_estimates <- iowa_polls_models %>%
mutate(ggplot_build = furrr::future_map(gam_graphs,  # this allows us to grab to data in ggplot
~ggplot_build(.x)),
# extract GAM parameters
gam_result = furrr::future_map(ggplot_build,
~.x[["data"]][[3]] %>%
slice(n())) %>%
map_dbl("y", .null = NA_real_),
# extract actual result in Iowa caucus
actual_result = furrr::future_map(ggplot_build,
~.x[["data"]][[2]] %>%
slice(1)) %>%
map_dbl("yintercept", .null = NA_real_),
# take forecast error for ct
forecast_error = actual_result - gam_result
) %>%
select(-ggplot_build)
extract_iowa_estimates <- iowa_polls_models %>%
mutate(ggplot_build = furrr::future_map(gam_graphs,  # this allows us to grab to data in ggplot
~ggplot_build(.x)),
# extract GAM parameters
gam_result = furrr::future_map(ggplot_build,
~.x[["data"]][[3]] %>%
slice(n())) %>%
map_dbl("y", .null = NA_real_),
# extract actual result in Iowa caucus
actual_result = furrr::future_map(ggplot_build,
~.x[["data"]][[2]] %>%
slice(1)) %>%
map_dbl("yintercept", .null = NA_real_),
# take forecast error for ct
forecast_error = actual_result - gam_result
) %>%
select(-ggplot_build)
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 4 polls in each window
filter(map_int(rolling_t, nrow) >= 5) %>%
# find distinct e_ct and p_ct
mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_mdoels = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
extract_iowa_estimates <- iowa_polls_models %>%
mutate(ggplot_build = furrr::future_map(gam_graphs,  # this allows us to grab to data in ggplot
~ggplot_build(.x)),
# extract GAM parameters
gam_result = furrr::future_map(ggplot_build,
~.x[["data"]][[3]] %>%
slice(n())) %>%
map_dbl("y", .null = NA_real_),
# extract actual result in Iowa caucus
actual_result = furrr::future_map(ggplot_build,
~.x[["data"]][[2]] %>%
slice(1)) %>%
map_dbl("yintercept", .null = NA_real_),
# take forecast error for ct
forecast_error = actual_result - gam_result
) %>%
select(-ggplot_build)
save(extract_iowa_estimates, file = here::here("data/iowa_extracted_spline_estimates.RData"))
ggplot(extract_iowa_estimates, aes(date, forecast_error)) +
# geom_point() + # might be nice to do this with geom_ribbon once we have CIs
geom_line() +
geom_hline(yintercept = 0,
color = ussc::ussc_colours("light blue")) +
facet_wrap(contest~last_name,
nrow = 5,
scales = "free_x") +
scale_x_datetime(date_labels = "%b\n'%y") +
theme_ussc() +
labs(x = NULL,
y = latex2exp::TeX("y_c - \\hat{y}_{ct}")) +
theme(panel.grid.minor = element_blank(),
axis.title.y = element_text(angle = 0),
panel.spacing.x=unit(1, "lines"))
View(extract_iowa_estimates)
View(extract_iowa_estimates[[6]][[81]])
tmp <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 4 polls in each window
filter(map_int(rolling_t, nrow) >= 5) %>% filter(last_name == "Harkin")
View(tmp)
View(tmp[[6]][[1]])
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 4 polls in each window
filter(map_int(rolling_t, nrow) >= 5) %>%
filter(last_name != "Harkin") %>%
# find distinct e_ct and p_ct
mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_mdoels = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
extract_iowa_estimates <- iowa_polls_models %>%
mutate(ggplot_build = furrr::future_map(gam_graphs,  # this allows us to grab to data in ggplot
~ggplot_build(.x)),
# extract GAM parameters
gam_result = furrr::future_map(ggplot_build,
~.x[["data"]][[3]] %>%
slice(n())) %>%
map_dbl("y", .null = NA_real_),
# extract actual result in Iowa caucus
actual_result = furrr::future_map(ggplot_build,
~.x[["data"]][[2]] %>%
slice(1)) %>%
map_dbl("yintercept", .null = NA_real_),
# take forecast error for ct
forecast_error = actual_result - gam_result
) %>%
select(-ggplot_build)
save(extract_iowa_estimates, file = here::here("data/iowa_extracted_spline_estimates.RData"))
ggplot(extract_iowa_estimates, aes(date, forecast_error)) +
# geom_point() + # might be nice to do this with geom_ribbon once we have CIs
geom_line() +
geom_hline(yintercept = 0,
color = ussc::ussc_colours("light blue")) +
facet_wrap(contest~last_name,
nrow = 5,
scales = "free_x") +
scale_x_datetime(date_labels = "%b\n'%y") +
theme_ussc() +
labs(x = NULL,
y = latex2exp::TeX("y_c - \\hat{y}_{ct}")) +
theme(panel.grid.minor = element_blank(),
axis.title.y = element_text(angle = 0),
panel.spacing.x=unit(1, "lines"))
ggsave(last_plot(),
file = here::here('graphs/iowa_past_splines.png'),
width = 8, height = 8)
library(ussc)
library(data.table)
library(dtplyr)
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
library(tidyr)
library(tibble)
library(here)
library(fs)
library(readxl)
library(lubridate)
library(stats)
library(nls.multstart) # devtools::install_github('padpadpadpad/nls.multstart')
library(brms)
library(slide) #remotes::install_github("DavisVaughan/slide") -- for rolling windows in purrr
library(mgcv)
library(nls2)
future::plan(future::multicore)
options(future.globals.maxSize = 2050 *1024^2)
if(file.exists(here::here("data/rolling_iowa_polls.RData"))){
load(here::here("data/rolling_iowa_polls.RData"))
}
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 5 polls in each window
filter(map_int(rolling_t, nrow) >= 5) %>%
filter(last_name != "Harkin") %>%
# find distinct e_ct and p_ct
mutate(unique_ect = map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(map_int(unique_ect, nrow) >= 4) %>%
filter(map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_models = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 5 polls in each window
filter(map_int(rolling_t, nrow) >= 5) %>%
filter(last_name != "Harkin") %>%
# find distinct e_ct and p_ct
mutate(unique_ect = purrr::map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = purrr::map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(purrr::map_int(unique_ect, nrow) >= 4) %>%
filter(purrr::map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_models = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
iowa_polls_models <- rolling_iowa_polls %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, e_ct))) %>%
mutate(rolling_t = purrr::map(rolling_t, ~drop_na(.x, p_ct))) %>%
# find distinct covariates for splines
# data must have >= 5 polls in each window
filter(purrr::map_int(rolling_t, nrow) >= 5) %>%
filter(last_name != "Harkin") %>%
# find distinct e_ct and p_ct
mutate(unique_ect = purrr::map(rolling_t, ~distinct(.x, e_ct)),
unique_pct = purrr::map(rolling_t, ~distinct(.x, p_ct))) %>%
filter(purrr::map_int(unique_ect, nrow) >= 4) %>%
filter(purrr::map_int(unique_pct, nrow) >= 4) %>%
select(-c(unique_ect, unique_pct)) %>%
mutate(gam_models = furrr::future_map(rolling_t,
~broom::tidy(gam(y_c~s(p_ct,
k = 3) +
s(e_ct,
k = 3),
data = .x,
weights = new_weight
))
),
# still not really working, ugh, so I'm going to try a basic GAM in ggplot and take the results from that
gam_graphs = furrr::future_map(rolling_t,
~ggplot(.x,  aes(t, p_ct)) +
geom_point() +
geom_hline(aes(yintercept = y_c)) +
geom_smooth(method = 'gam',
aes(predict(gam(formula = y_c ~ s(p_ct, k = 3) +
s(e_ct, k = 3),
data=.x,
weights = new_weight),
.x))
) +
scale_x_reverse() +
theme_ussc()
))
extract_iowa_estimates <- iowa_polls_models %>%
mutate(ggplot_build = furrr::future_map(gam_graphs,  # this allows us to grab to data in ggplot
~ggplot_build(.x)),
# extract GAM parameters
gam_result = furrr::future_map(ggplot_build,
~.x[["data"]][[3]] %>%
slice(n())) %>%
map_dbl("y", .null = NA_real_),
# extract actual result in Iowa caucus
actual_result = furrr::future_map(ggplot_build,
~.x[["data"]][[2]] %>%
slice(1)) %>%
map_dbl("yintercept", .null = NA_real_),
# take forecast error for ct
forecast_error = actual_result - gam_result
) %>%
select(-ggplot_build)
save(extract_iowa_estimates, file = here::here("data/iowa_extracted_spline_estimates.RData"))
